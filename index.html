<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SunarMC Client</title>
<style>
  html,body { height:100%; margin:0; background:#081020; overflow:hidden; }
  body { cursor: none; }

  #bg, #cursorLayer { position:fixed; left:0; top:0; width:100%; height:100%; display:block; }
  #cursorLayer { pointer-events:none; z-index:40; }

  .ui {
    position:fixed;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    z-index:50;
    text-align:center;
    font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    user-select:none;
    -webkit-user-select:none;
    width: 420px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:18px;
    pointer-events: auto;
  }

  .logo {
    font-weight:900;
    font-size:72px;
    letter-spacing:1px;
    line-height:0.9;
    margin:0;
    margin-top:-6px;
    margin-bottom:4px;
    background: linear-gradient(90deg, #e185ff 0%, #b25dff 40%, #6fc3ff 100%);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    text-shadow:
      0 8px 34px rgba(118,38,169,0.18),
      0 2px 6px rgba(0,0,0,0.6);
    transform-origin: center;
    animation: logoBreath 3500ms ease-in-out infinite;
  }
  @keyframes logoBreath {
    0% { transform: translateY(0) scale(1); filter: drop-shadow(0 6px 12px rgba(118,38,169,0.06)); }
    50% { transform: translateY(-2px) scale(1.01); filter: drop-shadow(0 10px 30px rgba(118,38,169,0.12)); }
    100% { transform: translateY(0) scale(1); filter: drop-shadow(0 6px 12px rgba(118,38,169,0.06)); }
  }

.splash {
  font-size:18px;
  color:#d9c06a;
  margin:0;
  font-weight:700;
  text-transform:none;
  text-shadow: 0 2px 6px rgba(0,0,0,0.55);
  transform-origin: center;
  will-change: transform, text-shadow;

  animation: splashPulse 1600ms ease-in-out infinite;
}

@keyframes splashPulse {
  0% {
    transform: translateX(150px) translateY(-25px) rotate(-25deg) scale(1);
    text-shadow: 0 2px 6px rgba(0,0,0,0.55);
  }
  50% {
    transform: translateX(150px) translateY(-25px) rotate(-25deg) scale(1.06);
    text-shadow: 0 8px 30px rgba(217,192,106,0.16);
  }
  100% {
    transform: translateX(150px) translateY(-25px) rotate(-25deg) scale(1);
    text-shadow: 0 2px 6px rgba(0,0,0,0.55);
  }
}

@media (prefers-reduced-motion: reduce) {
  .splash { animation: none; transform: translateX(150px) translateY(-25px) rotate(-25deg); }
}

  .menu {
    display:flex;
    flex-direction:column;
    gap:12px;
    margin-top:6px;
  }

  .btn {
    -webkit-appearance:none;
    appearance:none;
    border: 2px solid rgba(0,0,0,0.7);
    background: linear-gradient(#cfcfcf, #9f9f9f);
    width:260px;
    height:48px;
    border-radius:6px;
    box-shadow:
      inset 0 -6px 0 rgba(0,0,0,0.08),
      0 8px 0 rgba(0,0,0,0.42);
    display:flex;
    align-items:center;
    justify-content:center;
    color:#202020;
    font-weight:800;
    font-size:16px;
    letter-spacing:1px;
    text-transform:uppercase;
    cursor:default;
    position:relative;
    overflow:hidden;
    transition: transform 0.12s ease, box-shadow 0.12s ease;
    user-select:none;
  }
  .btn:active {
    transform: translateY(3px);
    box-shadow: inset 0 4px 8px rgba(0,0,0,0.25);
  }
  .btn:focus { outline: none; box-shadow: 0 10px 0 rgba(0,0,0,0.45); }

  .btn .label {
    display:inline-block;
    transform-origin:center;
    animation: menuPulse 1600ms ease-in-out infinite;
  }
  @keyframes menuPulse {
    0% { transform: translateY(0) scale(1); text-shadow: 0 0 0 rgba(255,255,255,0); }
    50% { transform: translateY(-2px) scale(1.02); text-shadow: 0 8px 20px rgba(255,255,255,0.06); }
    100% { transform: translateY(0) scale(1); text-shadow: 0 0 0 rgba(255,255,255,0); }
  }

  .hint { margin-top:6px; font-size:12px; color:rgba(255,255,255,0.68); }

  @media (max-width:480px){
    .logo{font-size:44px}
    .splash{font-size:14px}
    .btn{width:200px; height:42px; font-size:14px}
    .ui { width:320px; gap:12px; }
  }

  .changelog-panel {
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%) scale(0.98);
    width: min(920px, 92%);
    max-height: 82vh;
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 30px 80px rgba(0,0,0,0.7);
    border-radius: 12px;
    z-index: 120;
    padding: 18px;
    overflow: hidden;
    display: none;
    opacity: 0;
    transition: opacity 220ms ease, transform 220ms ease;
    color: #e6e6e6;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    pointer-events: auto;
  }
  .changelog-panel.open {
    display: block;
    opacity: 1;
    transform:translate(-50%,-50%) scale(1);
  }
  .changelog-header {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom: 12px;
  }
  .changelog-title { font-weight:800; font-size:18px; letter-spacing:0.6px; }
  .close-btn {
    -webkit-appearance:none;
    appearance:none;
    border:0;
    background:transparent;
    color: #cfcfcf;
    font-weight:700;
    cursor:pointer;
    font-size:14px;
    padding:6px 10px;
    border-radius:6px;
  }
  .close-btn:hover { background: rgba(255,255,255,0.02); }
  .changelog-body {
    overflow:auto;
    padding-right:8px;
    max-height: calc(82vh - 66px);
  }
  .changelog-body h1, .changelog-body h2, .changelog-body h3 { color:#fff; margin:10px 0 8px; }
  .changelog-body p { margin:6px 0 10px; color:#ddd; line-height:1.45; }
  .changelog-body pre { background: rgba(0,0,0,0.45); padding:10px; border-radius:8px; overflow:auto; color:#dcdcdc; }
  .changelog-body code { background: rgba(255,255,255,0.03); padding: 2px 6px; border-radius:6px; font-family: monospace; }
  .changelog-body a { color: #9fd6ff; text-decoration: none; }
  .changelog-body ul, .changelog-body ol { margin: 6px 0 10px 20px; color: #ddd; }
  .changelog-footer { margin-top:8px; font-size:12px; color: rgba(255,255,255,0.6); }
  .btn { cursor: pointer; }
</style>
</head>
<body>
<canvas id="bg"></canvas>
<canvas id="cursorLayer"></canvas>

<div class="ui" aria-hidden="false">
  <h1 class="logo">SunarMC</h1>
  <div class="splash">Beautiful</div>

  <div class="menu" role="menu" aria-label="Main menu">
    <button class="btn" id="downloadBtn" role="menuitem"><span class="label">Download</span></button>
    <button class="btn" id="changelogBtn" role="menuitem"><span class="label">View Changelog</span></button>
    <button class="btn" id="githubBtn" role="menuitem"><span class="label">Open on GitHub</span></button>
  </div>
</div>

<!-- changelog panel -->
<div class="changelog-panel" id="changelogPanel" aria-hidden="true" role="dialog" aria-label="Changelog / README">
  <div class="changelog-header">
    <div class="changelog-title">Changelog / README</div>
    <div><button class="close-btn" id="changelogClose">Close</button></div>
  </div>
  <div class="changelog-body" id="changelogBody" tabindex="0">
    <!-- README will be rendered here -->
  </div>
  <div class="changelog-footer" id="changelogFooter" style="display:none"></div>
</div>

<script>

const canvas = document.getElementById('bg');
const ctx = canvas.getContext('2d', { alpha: true });
const cursorCanvas = document.getElementById('cursorLayer');
const cctx = cursorCanvas.getContext('2d');

let W=0, H=0;
function resize(){
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  cursorCanvas.width = W;
  cursorCanvas.height = H;
}
addEventListener('resize', resize);
resize();

let backgroundDarkness = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches ? 0.8 : 0.5;

let mouse = {x: W/2, y: H/2};
let par = {x:0, y:0};
const parallaxMax = 26;
const parallaxLerp = 0.12;
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('touchmove', e => {
  if(e.touches && e.touches[0]) { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; }
}, {passive:true});

const rand = (a=0,b=1) => a + Math.random()*(b-a);
function hsvToRgb(h,s,v){
  let r,g,b;
  let i = Math.floor(h*6);
  let f = h*6 - i;
  let p = v*(1-s);
  let q = v*(1-f*s);
  let t = v*(1-(1-f)*s);
  switch(i%6){
    case 0: r=v; g=t; b=p; break;
    case 1: r=q; g=v; b=p; break;
    case 2: r=p; g=v; b=t; break;
    case 3: r=p; g=q; b=v; break;
    case 4: r=t; g=p; b=v; break;
    default: r=v; g=p; b=q; break;
  }
  return [r,g,b];
}
function rgb255(a){ return Math.max(0, Math.min(255, Math.floor(a*255))); }

let updateCounter = 0;
const bgStartTime = Date.now();

class Bubble {
  constructor(initial=false){
    this.baseRadius = 36.0 + Math.random()*140.0;
    this.radius = this.baseRadius;
    this.vy = 0.18 + Math.random()*0.9;
    this.bulgeSpeed = 0.4 + Math.random()*1.6;
    this.phase = Math.random() * Math.PI * 2;
    this.amplitude = 0.08 + Math.random()*0.48;
    const centers = [0.96, 0.80, 0.63];
    let pick = centers[Math.floor(Math.random()*centers.length)];
    let hueBase = (pick + (Math.random()*0.06 - 0.03) + 1) % 1.0;
    let sat = 0.50 + Math.random()*0.45;
    let val = 0.78 + Math.random()*0.22;
    const rgb = hsvToRgb(hueBase, sat, val);
    this.r = rgb[0]; this.g = rgb[1]; this.b = rgb[2];
    this.alpha = 0.16 + Math.random()*0.38;
    this.appearTimer = 0;
    this.appearDuration = 8 + Math.floor(Math.random()*36);
    this.appearAlpha = initial ? 1.0 : 0.0;
    this.x = Math.random()*(W+80) - 40;
    this.y = initial ? (Math.random()*(H+200) - 100) : -this.baseRadius - Math.random()*300;
    this.burst = 0;
  }
  update(){
    this.phase += this.bulgeSpeed * 0.018;
    if (Math.random() < 0.002) this.burst = 12 + Math.floor(Math.random()*36);
    if (this.burst > 0) this.burst--;
    const globalOsc = Math.sin(this.phase + updateCounter * 0.03);
    const amplitude = this.amplitude * (1.0 + this.burst * 0.01);
    const bulge = 1.0 + amplitude * globalOsc;
    this.radius = this.baseRadius * bulge;
    const sinkMultiplier = 1.0 - (amplitude * (globalOsc * 0.25));
    this.y += this.vy * sinkMultiplier * 0.55;
    this.x += Math.sin((this.phase * 0.7 + updateCounter * 0.01)) * (0.3 + amplitude * 0.45);
    if (this.appearTimer < this.appearDuration) {
      this.appearTimer++;
      this.appearAlpha = Math.min(1.0, this.appearTimer / this.appearDuration);
    } else this.appearAlpha = 1.0;
    if (this.y - this.radius > H + 60) {
      const nb = new Bubble(false);
      if (Math.random() < 0.8) {
        nb.y = -nb.baseRadius - Math.random()*200;
        nb.x = Math.random()*(W+60) - 30;
      } else {
        if (Math.random() < 0.5) { nb.x = -nb.baseRadius - Math.random()*150; nb.y = Math.random()*(H+200) - 100; }
        else { nb.x = W + nb.baseRadius + Math.random()*150; nb.y = Math.random()*(H+200) - 100; }
      }
      Object.assign(this, nb);
    }
  }
}

class Snowflake {
  constructor(){
    this.x = Math.random()*W;
    this.y = Math.random()*(H+200) - 200;
    this.size = 0.5 + Math.random()*1.1;
    this.speed = 0.15 + Math.random()*0.6;
    this.offset = Math.random()*10;
  }
  update(){
    this.y += this.speed;
    this.x += Math.sin((updateCounter * 0.01 + this.offset)) * 0.3;
    if (this.y > H + 5) {
      this.y = -5 - Math.random()*20;
      this.x = Math.random()*W;
    }
  }
}

let bubbles = [];
let snowflakes = [];
function initAnimatedBackground(){
  bubbles = [];
  snowflakes = [];
  const initialBubbleCount = Math.max(20, Math.floor((W*H)/45000));
  for (let i=0;i<initialBubbleCount;i++){
    const b = new Bubble(true);
    b.y = Math.random()*(H+200) - 100;
    b.x = Math.random()*(W+80) - 40;
    bubbles.push(b);
  }
  const snowCount = Math.max(120, Math.floor((W*H)/6000));
  for (let i=0;i<snowCount;i++) snowflakes.push(new Snowflake());
}
initAnimatedBackground();

function drawRadialCircle(ctxLocal, cx, cy, radius, cr, cg, cb, alpha){
  ctxLocal.save();
  let g = ctxLocal.createRadialGradient(cx,cy,Math.max(1,radius*0.05), cx,cy, radius);
  g.addColorStop(0, `rgba(${rgb255(cr)},${rgb255(cg)},${rgb255(cb)},${alpha})`);
  g.addColorStop(0.6, `rgba(${rgb255(cr)},${rgb255(cg)},${rgb255(cb)},${alpha*0.12})`);
  g.addColorStop(1, `rgba(${rgb255(cr)},${rgb255(cg)},${rgb255(cb)},0)`);
  ctxLocal.globalCompositeOperation = 'source-over';
  ctxLocal.fillStyle = g;
  ctxLocal.beginPath();
  ctxLocal.arc(cx, cy, radius, 0, Math.PI*2);
  ctxLocal.fill();
  ctxLocal.globalCompositeOperation = 'lighter';
  let glow = ctxLocal.createRadialGradient(cx,cy,radius*0.2, cx,cy, radius*1.28);
  glow.addColorStop(0, `rgba(${rgb255(cr)},${rgb255(cg)},${rgb255(cb)},${alpha*0.45})`);
  glow.addColorStop(0.55, `rgba(${rgb255(cr)},${rgb255(cg)},${rgb255(cb)},${alpha*0.08})`);
  glow.addColorStop(1, `rgba(${rgb255(cr)},${rgb255(cg)},${rgb255(cb)},0)`);
  ctxLocal.fillStyle = glow;
  ctxLocal.beginPath();
  ctxLocal.arc(cx, cy, radius*1.28, 0, Math.PI*2);
  ctxLocal.fill();
  ctxLocal.restore();
}

function drawSnowflakeGlow(ctxLocal, x, y, size) {
  const a = 0.9 * (0.5 + 0.5 * Math.abs(Math.sin((updateCounter + x)*0.02)));
  drawRadialCircle(ctxLocal, x, y, size * 3.0, 1.0, 1.0, 1.0, a);
}

let last = performance.now();
function frame(now){
  const dt = Math.min(0.2, (now - last)/1000);
  last = now;
  updateCounter++;

  const targetX = Math.max(-1, Math.min(1, (mouse.x - W*0.5)/(W*0.5)));
  const targetY = Math.max(-1, Math.min(1, (mouse.y - H*0.5)/(H*0.5)));
  par.x += (targetX - par.x) * parallaxLerp;
  par.y += (targetY - par.y) * parallaxLerp;
  const parallaxShiftX = par.x * parallaxMax;
  const parallaxShiftY = par.y * parallaxMax * 0.6;

  ctx.clearRect(0,0,W,H);

  const nowMs = Date.now();
  const rawT = ((nowMs - bgStartTime) % 24000) / 24000;
  const smoothT = 0.5 - 0.5 * Math.cos(rawT * Math.PI * 2.0);

  const topHue = (smoothT * 0.12 + 0.89) % 1.0;
  const bottomHue = ((smoothT + 0.22) * 0.12 + 0.7) % 1.0;
  const topColor = hsvToRgb(topHue, 0.65, 0.98);
  const bottomColor = hsvToRgb(bottomHue, 0.60, 0.92);

  const colorBoost = 1.12;
  for (let i=0;i<3;i++){
    topColor[i] = Math.min(1.0, topColor[i] * colorBoost * backgroundDarkness);
    bottomColor[i] = Math.min(1.0, bottomColor[i] * colorBoost * backgroundDarkness);
  }

  let grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0, `rgb(${rgb255(topColor[0])},${rgb255(topColor[1])},${rgb255(topColor[2])})`);
  grad.addColorStop(1, `rgb(${rgb255(bottomColor[0])},${rgb255(bottomColor[1])},${rgb255(bottomColor[2])})`);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);

  const washColor = hsvToRgb((smoothT * 0.2 + 0.6) % 1.0, 0.75, 1.0);
  for (let i=0;i<3;i++) washColor[i] *= backgroundDarkness;
  const washAlpha = 0.09;
  const offsetX = Math.sin(nowMs * 0.00016) * 60.0;
  const offsetY = Math.cos(nowMs * 0.00011) * 28.0;
  ctx.save();
  ctx.globalAlpha = washAlpha;
  ctx.fillStyle = `rgba(${rgb255(washColor[0])},${rgb255(washColor[1])},${rgb255(washColor[2])},1)`;
  ctx.translate(parallaxShiftX * 0.6 + offsetX, parallaxShiftY * 0.6 + offsetY);
  ctx.beginPath();
  ctx.rect(-120, -120, W + 240, H + 240);
  ctx.fill();
  ctx.restore();

  const maxBubbles = Math.max(36, Math.floor((W*H)/40000));
  if (bubbles.length < maxBubbles && Math.random() < 0.06) bubbles.push(new Bubble(false));
  for (let b of bubbles) b.update();
  for (let s of snowflakes) s.update();

  for (let b of bubbles) {
    const finalAlpha = b.alpha * b.appearAlpha * 1.0;
    const bulgeOsc = Math.sin(b.phase + updateCounter*0.035);
    const bulge = 1.0 + b.amplitude * bulgeOsc;
    const r = b.baseRadius * bulge;
    const rr = b.r * backgroundDarkness;
    const gg = b.g * backgroundDarkness;
    const bb = b.b * backgroundDarkness;
    const depth = 0.4 + (b.baseRadius / 300.0);
    drawRadialCircle(ctx, b.x + parallaxShiftX * depth, b.y + parallaxShiftY * depth, r, rr, gg, bb, finalAlpha);
  }

  for (let s of snowflakes) drawSnowflakeGlow(ctx, s.x + parallaxShiftX * 0.35, s.y + parallaxShiftY * 0.35, s.size);

  const vign = ctx.createLinearGradient(0,0,0,H);
  vign.addColorStop(0, 'rgba(0,0,0,0.02)');
  vign.addColorStop(0.6, 'rgba(0,0,0,0.12)');
  vign.addColorStop(1, 'rgba(0,0,0,0.28)');
  ctx.fillStyle = vign;
  ctx.fillRect(0,0,W,H);

  drawCursorOverlay(dt);

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

const customCursorAlpha = 0.65;
const customCursorRadius = 6;
const cursorSmoothness = 20.0;
let cursorX = W/2, cursorY = H/2, cursorTargetX = W/2, cursorTargetY = H/2;
let cursorLastTime = performance.now();
let clickAnimating = false, clickAnimProgress = 0;
const clickAnimDuration = 0.18;

window.addEventListener('mousemove', e => { cursorTargetX = e.clientX; cursorTargetY = e.clientY; });
window.addEventListener('touchstart', e => { if(e.touches && e.touches[0]) { cursorTargetX = e.touches[0].clientX; cursorTargetY = e.touches[0].clientY; }}, {passive:true});
window.addEventListener('mousedown', startClickAnim);
window.addEventListener('touchstart', startClickAnim, {passive:true});

function startClickAnim(){ clickAnimating = true; clickAnimProgress = 0; }

function drawCursorOverlay(dt){
  const now = performance.now();
  const rawDt = Math.min(0.2, (now - cursorLastTime)/1000);
  cursorLastTime = now;
  const alphaS = 1 - Math.exp(-cursorSmoothness * rawDt);
  cursorX += (cursorTargetX - cursorX) * alphaS;
  cursorY += (cursorTargetY - cursorY) * alphaS;

  if (clickAnimating) {
    clickAnimProgress += rawDt / clickAnimDuration;
    if (clickAnimProgress >= 1.0){ clickAnimProgress = 1.0; clickAnimating = false; }
  }

  cctx.clearRect(0,0,W,H);
  cctx.save();

  cctx.globalAlpha = customCursorAlpha;
  cctx.beginPath();
  const coreScale = 0.9 + 0.15 * (1 + (-Math.pow(1-clickAnimProgress,3)));
  cctx.arc(cursorX, cursorY, customCursorRadius * coreScale, 0, Math.PI*2);
  cctx.fillStyle = 'rgba(255,255,255,1)';
  cctx.fill();

  cctx.globalAlpha = customCursorAlpha * 0.45;
  cctx.lineWidth = 1.2;
  cctx.beginPath();
  cctx.arc(cursorX, cursorY, customCursorRadius + 0.6, 0, Math.PI*2);
  cctx.strokeStyle = 'rgba(255,255,255,1)';
  cctx.stroke();

  if (clickAnimProgress > 0){
    const progress = clickAnimProgress;
    const rippleRadius = customCursorRadius + (30 * progress);
    const rippleA = (1.0 - progress) * 0.9;
    cctx.globalAlpha = rippleA;
    cctx.lineWidth = 2.0;
    cctx.beginPath();
    cctx.arc(cursorX, cursorY, rippleRadius, 0, Math.PI*2);
    cctx.strokeStyle = 'rgba(255,255,255,1)';
    cctx.stroke();
  }

  cctx.restore();
}

const RAW_REPO = 'https://github.com/MikaSukie/Sunar-MC/';
const changelogPanel = document.getElementById('changelogPanel');
const changelogBody = document.getElementById('changelogBody');
const changelogClose = document.getElementById('changelogClose');
const changelogFooter = document.getElementById('changelogFooter');

let readmeRendered = false;

const README_MD = `# SunarMC
## Development progress: in progress
### The changelogs might have not recorded all changes but most.
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/1602c651-1f75-4981-bbe3-10633bd04d19" /> <br>
total recorded changelogs:
adds Mojang API skins but falling back to a different faster API
-weather changer <br>
-scrollable chat <br>
-option for unlimited chat history <br>
-EXPORTING CHAT <br>
-custom setting for chat history <br>
-Server list fix from button suddenly taking you to the menu <br>
-fixed the leave bed button not working <br>
-fixed the sending a message while in a bed crash <br>
-NEW DEBUG MENU LAGOMETER VISUALS <br>
-Added multiplayer mob jitter fix <br>
-more info to the f3 debug menu <br>
-removed the LAGGY lagometer from vanilla <br>
-Fixed music slider not updating live <br>
*-fixed weather changer  <br>
Attachment file type: unknown <br>
*-Fixed pressing escape now resets chat scroll <br>
-Chunk borders <br>
-multi-key binds saving and loading. <br>
-F3 MENU UPDATE <br>
-Another QOL f3 menu update to change facing direction from 0 1 2 3 into North (-Z) etc <br>
-Does not download the assets.zip when not needed, MASSIVELY speeds up the game. <br>
-sha256-checksum checking so even if my hosted version of the assets.zip gets hacked or malicously changed the clients will NOT apply it. <br>
-showcase of the new f3 menu I have modified with the new compass addition. <br>
-Rewrote the keybinding system to support multi-key keybinding <br>
-added chunk borders (slightly scuffed but usable.) <br>
-Changed the control gui to be a double click and have  sub gui where you can optionally type they keybind you wish to set. <br>
-Changed every textbox in the game to be of convenience. Allowing select, edit, different text cursor, copy and paste. <br>
-removed random square in the f3 menu <br>
-ADDED VSYNC <br>
-taking a screenshot and clicking it now opens it <br>
-added proper 1.10-like chunk borders (had to code from scratch) <br>
-F3 debug cursor <br>
-fist inertia (interpolated) Also this applies for items as well. <br>
-fist is no longer affected by the FOV slider. (by rendering in screen space.) <br>
-fixed the fist inertia to apply while swinging and items STILL being affected by FOV slider <br>
-3D cursor does not show in third person since it is not usefull in 3rd person <br>
-3D dropped items <br>
-visually stacked and collected items <br>
-fist lerping/interpolation is toggleable <br>
-music gui has a new open music folder for ease of access <br>
-texturepacks button is moved into <br>
CONVENIENCE FEATURE ALERT!!!! ‚ö†Ô∏è  You can now hold SPACE ON LADDERS!!! üëè <br>
-crosshair no longer appears in non first person camera since there is no point. <br>
-ACTUALLY fixed the lerping STILL applying WHILE DISABLED. for the fist and items. <br>
-2nd layer while sneaking not moving has been patched <br>

-coming with a NEW UI design, dynamic also interacts with the mouse, <br>
-confirm to quit <br>
-f3 debug menu save state option <br>
-etc!!!! <br>

-Actually fixed the version number for fix 1 <br>

-light dark theme toggle <br>
-custom cursor since some people report broken cursor on screenshare or etc <br>
-option to disable the V2 ui <br>
-skin fetching slightly faster. (tried my best to async it.) <br>
-toggleable custom mouse cursor and slider for size <br>

-improved keybind support and fixed chunkborders initializing as null <br>

-fixed armor rendering <br>

-AGAIN fixed the keybinding system. <br>

-Fixed the 3D cursor X and Z being inverted. <br>

-AFTER 18 LOCAL PATCHES Finally the first Release 2 Fix 7 Best Effort Red Blue Inversion patch <br>
-Class rewrites for macos having R and B swaps üò≠ <br>

-main menu flicker fix for the old gui users, <br>
-V2 ui works in the world loading ui but also toggles with the same option to disable/enable V2 ui <br>
-Mining fix and placement fix only for white listed servers. <br>
--this list is public at: https://github.com/MikaSukie/b1.7.3-Assets/blob/main/fixblacklist.txt <br>
--the same repo that supplies the assets for the client. <br>
-fixed the holding left click delay timer that was SO ANNOYING (this.leftClickCounter = 10; now being this.leftClickCounter = 0;) <br>
-new splash screen complete with making the loading screen WAIT for resource downloads to prevent crashes that should have not been happening at all.  <br>

-Modern crafting using right click dragging <br>
-improved the loading screen preventing GL state overflowing <br>

-ACUTALLY implemented a working fix and feature for hotbar swapping number number. <br>
-Chat logging on/off seting and open chat exports folder <br>
-Reorganized the sunarmc gui settings. <br>
-ALSO HOLY!!!! 2ND LAYER SKINS WORK!!!!  <br>
-ALSO NEW FEATURE! I MANUALLY added the minimap üò≠ it works!!!! <br>
-Chat visual settings for configuring chat opacity, width, and the typing box opacity <br>

forgot "GL11.glDepthMask(true);" so now rendering should be fixed. <br>
fixed the minimap textboxes not being clickable üòÖ  <br>
and NEW FIST FOV SLIDER! <br>

Minor bug fixes so version number not incremented but fixID has been changed. <br>
Rewrote the entire model renderer class and etc for the player since there was a bug where skeletons and zombies had the same model as the player üíÄ  <br>
also some ui redesign and changes <br>
-tried to remove herobrine but bro duplicated and become 45 <br>

fixed slider formatting <br>
also added fps counter, AAAND proper minimap memory protections <br>
default will show on default slider values <br>

-Added Discord RPC <br>
-Massive Backend changes including a new instance system for the client. <br>
--basically a lot of the structure, client code has been rewritten and organized. <br>
-this will ship as a minor update even though its the biggest update. <br>
-hotbar keys are now configurable keybinds, also <br>
-Custom skin server has been implemented. so if you want a custom skin or cape DM or Ping me. Application can take 5-10 minutes but <br>
-changing capes will take 30min-1 hour <br>

-minimap arrow is finally an ACTUAL arrow not 2 boxes. <br>
-new slider for crouch interoplation so smooth 3rd person and other player crouching <br>
-fixed a 2nd layer angles not copying bug. <br>
-FINALLY FIXED THE double shutdown bug and crashing on game close that has existed since R1 (holy)`;

function simpleMarkdownToHtml(md){
  md = md.replace(/\r\n/g,'\n');

  const codeBlocks = [];
  md = md.replace(/```([\s\S]*?)```/g, (m, p1) => {
    const id = codeBlocks.push(p1) - 1;
    return `\n\n@@CODEBLOCK:${id}@@\n\n`;
  });

  md = md.replace(/^###### (.*)$/gm, '<h6>$1</h6>');
  md = md.replace(/^##### (.*)$/gm, '<h5>$1</h5>');
  md = md.replace(/^#### (.*)$/gm, '<h4>$1</h4>');
  md = md.replace(/^### (.*)$/gm, '<h3>$1</h3>');
  md = md.replace(/^## (.*)$/gm, '<h2>$1</h2>');
  md = md.replace(/^# (.*)$/gm, '<h1>$1</h1>');

  md = md.replace(/^\s*---\s*$/gm, '<hr/>');

  md = md.replace(/(^|\n)([ \t]*[-\*] .+(?:\n[ \t]*[-\*] .+)*)/g, (m, p1, p2) => {
    const items = p2.split(/\n/).map(l => l.replace(/^[ \t]*[-\*] /, '').trim());
    return p1 + '<ul>' + items.map(it => `<li>${it}</li>`).join('') + '</ul>';
  });
  md = md.replace(/(^|\n)([ \t]*\d+\..+(?:\n[ \t]*\d+\..+)*)/g, (m,p1,p2) => {
    const items = p2.split(/\n/).map(l => l.replace(/^[ \t]*\d+\.\s*/, '').trim());
    return p1 + '<ol>' + items.map(it => `<li>${it}</li>`).join('') + '</ol>';
  });

  md = md.replace(/`([^`\n]+)`/g, (m,p1) => `<code>${p1}</code>`);

  md = md.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  md = md.replace(/\*([^*]+)\*/g, '<em>$1</em>');

  md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

  const blocks = md.split(/\n{2,}/).map(b => b.trim()).filter(Boolean);
  const wrapped = blocks.map(b => {
    if (/^<\/?(h|ul|ol|li|pre|img|hr|blockquote|code|table)/i.test(b)) return b;
    return '<p>' + b.replace(/\n/g, '<br>') + '</p>';
  }).join('\n\n');

  let final = wrapped;

  final = final.replace(/@@CODEBLOCK:(\d+)@@/g, (m,id) => {
    const code = codeBlocks[Number(id)] || '';
    const esc = code.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    return `<pre><code>${esc}</code></pre>`;
  });

  return final;
}

function renderReadme(){
  if (readmeRendered) return;
  try {
    changelogBody.innerHTML = simpleMarkdownToHtml(README_MD);
    changelogFooter.style.display = 'block';
    changelogFooter.innerHTML = 'Rendered from local README copy. <a href="' + RAW_REPO + '" target="_blank" rel="noopener">Open on GitHub</a>';
    readmeRendered = true;
  } catch (err) {
    changelogBody.innerHTML = '<p style="color:rgba(255,255,255,0.6)">Failed to render README.</p><p><a href="' + RAW_REPO + '" target="_blank" rel="noopener">Open on GitHub</a></p>';
    console.warn('renderReadme error', err);
  }
}

function showChangelog(){
  renderReadme();
  changelogPanel.classList.add('open');
  changelogPanel.setAttribute('aria-hidden','false');
  setTimeout(()=> changelogBody.focus(), 200);
}
function hideChangelog(){
  changelogPanel.classList.remove('open');
  setTimeout(()=> changelogPanel.setAttribute('aria-hidden','true'), 240);
}

changelogClose.addEventListener('click', hideChangelog);
changelogPanel.addEventListener('click', (e) => {
  if (e.target === changelogPanel) hideChangelog();
});

document.querySelectorAll('.btn').forEach(b=>{
  b.addEventListener('pointerdown', e => { startClickAnim(); });

  b.addEventListener('click', (ev) => {
    if (b.id === 'downloadBtn') {
      window.open('https://github.com/MikaSukie/Sunar-MC/raw/refs/heads/main/SunarMC-R4-F9-Doccahiatto.jar', '_blank');
    } else if (b.id === 'changelogBtn') {
      if (changelogPanel.classList.contains('open')) hideChangelog();
      else showChangelog();
    } else if (b.id === 'githubBtn') {
      window.open('https://github.com/MikaSukie/Sunar-MC/', '_blank');
    }
  });
});

addEventListener('resize', () => {
  resize();
  initAnimatedBackground();
});
</script>
</body>
</html>
